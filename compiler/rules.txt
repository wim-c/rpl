# Note that the type hierarchy that is defined with the :> relation *must* be a
# lattice.  This is not checked the rule compiler!  For example, this is why
# compare is explicitly a subtype of binop here.

# Single node reductions.
push_END           :  END
push_THEN          :  THEN
push_bytes         :  bytes
push_contif        :  contif
push_data          :  data
push_define_data   :  define_data
push_define_macro  :  define_macro
push_define_proc   :  define_proc
push_if            :  if
push_label         :  label
push_macro         :  macro
push_proc          :  proc
push_proc_body     :  proc_body
push_program       :  program
push_statements    :  statements
push_symbol        :  symbol
push_words         :  words

# Unary operators.
unop  :>  int not

# Binary operators.
binop  :>  * + - / \ and or compare

# Unary operators on words.
word_unop  :  word unop

# Binary operators on words.
word_word_binop  :  word word binop

# Generalization of compile time constant terms.
const  :>  word ref expr

# Coerce argument to expr in const unary.
const_unop  : const unop

# Coerce first argument to expr in const binary.
const_const_binop  : const const binop

# Unary expressions.
expr_unop  :  expr unop

# Binary expressions.
expr_expr_binop   : expr expr binop
expr_const_binop  : expr const binop

# Generalization of goto and gosub.
branch  :>  goto gosub

# Reference branch folding.
ref_branch?  :  ref branch

# Constant goto and gosub folding
const_branch?  :  const branch

# Store final commands following a mark on the mark itself.
mark_goto?   :  mark goto
mark_final?  :  mark return
mark_final?  :  mark stop
mark_mark?   :  mark mark

# Generalization of boolean binary operators.
compare  :>  < <= <> = > >=

# Simplify negated boolean operators
compare_not  :  compare not
