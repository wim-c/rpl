# Skip unused marks
push_mark?  :  mark

# Include referenced code and possibly optimize.
push_gosub?  :  gosub

# Generalization of conditional branches.
cond  :>  beq bne

# Include referenced code and possibly optimize branch target.
push_cond?  :  cond

# Include referenced code and possibly optimize jump target.
push_goto?  :  goto

# Simplify zero offset goto.
goto_mark?  :  goto mark

# Simplify conditional branch over a GOTO or RETURN command..
cond_goto_mark?    :  cond goto mark
cond_return_mark?  :  cond return mark

# Tail call optimization.
gosub_return  :  gosub return

# Simplify costant conditional branches
word_cond  :  word cond
word_eq_cond?  :  word = cond
word_neq_cond?  :  word <> cond

# Commands
command  :>  ! # $ % * + - . / ; < <= <> = > >= @ \ ^ and beq bne chr$ clr fn
command  :>  for get gosub goto input int new next not on or peek poke print
command  :>  req return rnd rne stop str$ sys

# Constants
const  :>  expr ref word

# Commands that always divert execution flow.
final  :>  goto return stop

# Skip code following a final command.
final_command  :  final command
final_const    :  final const

# Fold identitical final commands separated by a mark
final_mark?  :  final mark
